Explanations for Udacity Machine Learning Engineer Nanodegree Technical Interview Questions

Question 1: Given two strings s and t, determine whether some anagram of t is a substring of s. For example if s = ‘udacity’ and t=‘ad’ then the function returns True. Your function definition should look like:

     question1(s,t) and return boolean True or False

Clarify the Question:

- The strings ’s’ and ’t’ can be any number of characters?
- Will s always be smaller than t?
- If s = ‘They were the best of times’ and t = ‘weretimes’, would t be considered a substring of s?
- If s = ‘R’ and t = ‘r’ would t be considered a substring of s?

Confirming Inputs and Outputs:

- Input: 2 strings
- Output: boolean True or False statement

Test Cases:

- None type is not a string, so I don’t think we need to consider it for our algorithm.
- If s and t were both empty strings, the algorithm would return True, since all of the elements of t are included in s.
- If t was an empty string and s was a string with elements, the algorithm would return True, since all of the elements of t are included in s.

Brainstorm:

- We could set a counter to 0 and iterate through the s string. Every time an element in s is the same as t we could add one to our counter. If the counter is equal to the number of characters in t, then return True. But if there are duplicate characters in s that are the same as a character in t they would be counted twice.
- If we iterate through s and find a match with t, we could mark a boolean variable r as True. When we are finished iterating through t and r is True, we could add one to the counter.

Runtime analysis:

- Since we need to go through each element of string s once and each element of string t once for every element of s, I believe the runtime is O(n,m) = nm, where m is the number of characters in string s and n is the number of characters in string t.


Question 2
Given a string a, find the longest palindromic substring contained in a. Your function definition should look like question2(a), and return a string.

Clarify the question:

- If we have two or more palindromic substrings that are the longest and the same length, should our algorithm return the first substring in the string or all substrings? For the purposes of this exercise, I will assume we want the first substring.
- Is a palindromic substring is defined as a string that is equal to itself in reverse?
- Empty strings are palindromic? I will assume yes

Confirming inputs and outputs:

- Input: a string
- Output: a string

Test cases:

- None type is not a string, so I don’t think we need to consider it for our algorithm.
- Since empty strings are palindromic, if our input was an empty string our output should also be an empty string.
- If we have a string of one character, we should return a string of one character.
- If we have a string of all different characters, we should return a string of the first character.
- If we have a string that includes two different palindromes of the same length, the algorithm should output the first string.

Brainstorm:

- We could start by setting up an empty string which will represent the largest palindrome as lp.
- We could run a for loop for each ith character of the string, and a for loop for each jth subsequent character following the ith character.
- For each jth and ith character, we could setup a string where the ith character is the first and the jth character is the last. We could then reverse the string and if it is equal to the original string and the number of characters is larger than the current largest palindrome (lp), we could set that as lp.
- Once the two loops are finished, return lp

Runtime analysis:

- We need to go through each character of string s once. We also need to go through m-1 iterations for each ith character in string s, where m is the number of characters between the ith and last character, inclusive. The most we would need to go through would be n-1 for the first character, so the worst case runtime would be approximately O(n) = n^2.

Question 3
Given an undirected graph G, find the minimum spanning tree within G. A minimum spanning tree connects all vertices in a graph with the smallest possible total weight of edges. Your function should take in and return an adjacency list structured like this:

{'A': [('B', 2)],
 'B': [('A', 2), ('C', 5)],
 'C': [('B', 5)]}

Clarify the question:

- If there are two or minimum spanning trees, do we produce one? Pick the first the algorithm finds.
- If there is a graph with no nodes, would the output be an empty dictionary?

Confirming inputs and outputs:

- The input is an adjacency list in a format of a python dictionary. The keys are the nodes, and the values are lists with tuples. The 1st element is the connecting node, the 2nd element is the weight of the edge that connects the nodes.
- The output is an adjacency list with the same characteristics as the input, but will represent the minimum spanning tree.

Test cases:

- If G was an empty dictionary, the output would be an empty dictionary.
- If G had one element with no edges, it would be initialized as {‘A’ : None} for example. The output should be the same.
- If G was an adjacency list with two minimum spanning trees, the algorithm would pick the first.

Brainstorm:

- We will use a greedy choice algorithm in order to find the minimum spanning algorithm.
- We can start by sorting the weights of the edges in increasing order.
- We could then iterate through the weights, starting with the smallest. If it forms a cycle with the spanning tree, discard it. If not, include it in the spanning tree.
- If there are N nodes, the minimum spanning tree will have N-1 edges. Therefore, repeat until there are N-1 edges.

Runtime Analysis:

-  If E is the number of edges, we have to sort E weights. If we use the python function sorted(), it uses Timsort. Timsort is a hybrid between merge and insertion sort. Best case, it’s O(E) = E. Average and worst case, it’s O(E) = Elog(E).
- Next, we need to iterate through the edges starting with the edge with the smallest weight. Best case, we will only need to iterate through N-1 edges. Worst case, we will need to check them all. For each edge, we will need to check if it forms a cycle when added to the edges already selected for the minimum spanning tree. Best case is the cycle only contains one edge, worst case it contains all of them. So this step is approximately O(E) = E*E.
- Overall, the runtime will be O(E) = E*E + Elog(E). Since E^2 is greater than Elog(E) overall, we can approximate the runtime O(E) = E^2.




